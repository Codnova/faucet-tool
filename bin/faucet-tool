#!/usr/bin/env node

'use strict';

/**
 * Module imports
 */

const argv = require('minimist')(process.argv.slice(2));
const { FaucetTool } = require('..');
const fs = require('fs');
const os = require('os');
const QRCode = require('qrcode');

/**
 * Constants
 */

const FAUCET_TOOL_DIR = os.homedir() + '/.hnsFaucetTool/';
const VALID_CMDS = ['createaddress', 'createmultisig'];
const VALID_OPTS  = ['n', 'l', 'b'];

/**
 * Processes commands and runs tool
 */

(async function() {
  try {
    const { cmd, args, opts } = parseCmd(argv);
    const tool = new FaucetTool({
      network: opts.n,
      language: opts.l,
      bits: opts.b
    });

    switch (cmd) {
      case VALID_CMDS[0]:
        await createAddress(tool, args);
        break;

      case VALID_CMDS[1]:
        await createMultisig(tool, args);
        break;
    }

    process.exit(0);
  } catch (err) {
    usage(err);
    process.exit(1);
  }
}());

/**
 * Creates a Bech32 encoded, HNS address.
 * @param {Object} tool - an instance of FaucetTool
 * @param {Array} args - arguments captured from standard input
 */

async function createAddress(tool, args) {
  if (args.length !== 0)
    usage(`createaddress expects 0 args`);

  const address = tool.getAddress();
  const ciphertext = await FaucetTool.encryptData(address);
  const details =
`Seed phrase:
${tool.getPhrase()}

Address:
${address}

Encrypted address:
${ciphertext}

Private key:
${tool.getPrivkey()}

Public key:
${tool.getPubkey()}
`;

  return render(address, ciphertext, details);
}

/**
 * Creates a Bech32 encoded, HNS multisig address.
 * @param {Object} tool - an instance of FaucetTool
 * @param {Array} args - arguments captured from standard input
 */
async function createMultisig(tool, [nrequired, ...keys]) {
  if ((nrequired >>> 0) !== nrequired)
    usage('nrequired should be an Int');

  if (nrequired > keys.length)
    usage('nrequired should not be larger than the number of keys');

  if (nrequired + keys.length < 3)
    usage(`createmultisig expects at least 3 args`);

  keys.forEach(key => {
    if (!FaucetTool.isValidPubkey(key))
      usage(`invalid pubkey: ${key}`);
  });

  const multisig = await FaucetTool.createMultisig(tool.getNetwork(), nrequired, keys);
  const ciphertext = await FaucetTool.encryptData(multisig.address);
  const details =
`Multisig address:
${multisig.address}

Encrypted multisig address:
${ciphertext}

Redeem script:
${multisig.redeemScript}
`;

  return render(multisig.address, ciphertext, details);
}

/**
 * Renders wallet info and encrypted address to stdout
 * and writes them as files to disk.
 * @param {String} address - the generated address
 * @param {String} ciphertext - the encrypted address
 * @param {String} details - the wallet details
 */

async function render(address, ciphertext, details) {
  const prefix = FAUCET_TOOL_DIR + address;
  const detailsPath = prefix + '_details.txt';
  const codePath = prefix + '_encrypted_address_QR_code.png'

  if (!fs.existsSync(FAUCET_TOOL_DIR))
    fs.mkdirSync(FAUCET_TOOL_DIR);

  await QRCode.toFile(codePath, ciphertext);
  fs.writeFileSync(detailsPath, details);

  details +=
`
The following files were created:
  ${detailsPath} [1]
  ${codePath} [2]

  [1]: Wallet information
  [2]: QR code of encrypted address
`;

  console.log(details);
}

/**
 * Parses command arguments.
 * @param {Object} argv - parsed output minimist
 * @returns {Object} ret - parsed command info
 * @returns {String} ret.cmd - command name
 * @returns {String} ret.args - command args
 * @returns {Object} ret.opts - command options
 */

function parseCmd(argv) {
  let cmd = argv._[0],
      args = argv._.slice(1),
      nopts = 0,
      opts = argv;

  if (!VALID_CMDS.includes(cmd))
    usage(`invalid command: ${cmd}`);

  for (let opt in opts) {
    if (opts.hasOwnProperty(opt)) {
      if (opt === '_')
        continue;

      if (!VALID_OPTS.includes(opt))
        usage(`invalid option: -${opt}`);

      nopts++;
    }
  }

  if (nopts > 3)
    usage('too many options');

  return { cmd, args, opts };
}

/**
 * Displays error message and exits process
 * @param {String|Error} err - the error message or object
 */

function usage(err) {
  const msg =
`faucet-tool: ${err}
usage:
  $ faucet-tool createaddress [-n string] [-l string] [-b number]
  $ faucet-tool createmultisig <required> <pubkey1> <pubkey2> ...'

Options:
  -n <network> (default "main")
  -l <seed language> (default "english")
  -b <bits of entropy> (default 256)
`;

  if(typeof err === 'string') {
    console.log(msg);
  } else {
    console.error(err);
  }

  process.exit(1);
}
